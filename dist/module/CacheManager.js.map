{"version":3,"sources":["CacheManager.ts"],"names":["_","FileSystem","SHA1","BASE_DIR","cacheDirectory","CacheEntry","uri","options","cacheKey","getCacheEntry","path","exists","tmpPath","downloadPromise","download","createDownloadResumable","downloadAsync","result","status","undefined","moveAsync","from","to","CacheManager","entries","deleteAsync","idempotent","makeDirectoryAsync","getInfoAsync","Error","size","filename","substring","lastIndexOf","indexOf","length","ext","sha","uniqueId","info"],"mappings":"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","sourcesContent":["// @flow\nimport * as _ from \"lodash\";\nimport * as FileSystem from \"expo-file-system\";\nimport SHA1 from \"crypto-js/sha1\";\n\nexport interface DownloadOptions {\n  md5?: boolean;\n  headers?: { [name: string]: string };\n}\n\nconst BASE_DIR = `${FileSystem.cacheDirectory}expo-image-cache/`;\n\nexport class CacheEntry {\n  uri: string;\n\n  options: DownloadOptions;\n\n  cacheKey: string;\n\n  downloadPromise: Promise<string | undefined> | undefined;\n\n  constructor(uri: string, options: DownloadOptions, cacheKey: string) {\n    this.uri = uri;\n    this.options = options;\n    this.cacheKey = cacheKey;\n  }\n\n  async getPath(): Promise<string | undefined> {\n    const { cacheKey } = this;\n    const { path, exists, tmpPath } = await getCacheEntry(cacheKey);\n    if (exists) {\n      return path;\n    }\n    if (!this.downloadPromise) {\n      this.downloadPromise = this.download(path, tmpPath);\n    }\n    return this.downloadPromise;\n  }\n\n  private async download(path: string, tmpPath: string): Promise<string | undefined> {\n    const { uri, options } = this;\n    const result = await FileSystem.createDownloadResumable(uri, tmpPath, options).downloadAsync();\n    // If the image download failed, we don't cache anything\n    if (result && result.status !== 200) {\n      this.downloadPromise = undefined;\n      return undefined;\n    }\n    await FileSystem.moveAsync({ from: tmpPath, to: path });\n    return path;\n  }\n}\n\nexport default class CacheManager {\n  static entries: { [uri: string]: CacheEntry } = {};\n\n  static get(uri: string, options: DownloadOptions, cacheKey: string): CacheEntry {\n    if (!CacheManager.entries[cacheKey]) {\n      CacheManager.entries[cacheKey] = new CacheEntry(uri, options, cacheKey);\n    }\n    return CacheManager.entries[cacheKey];\n  }\n\n  static async clearCache(): Promise<void> {\n    await FileSystem.deleteAsync(BASE_DIR, { idempotent: true });\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  }\n\n  static async getCacheSize(): Promise<number> {\n    const result = await FileSystem.getInfoAsync(BASE_DIR);\n    if (!result.exists) {\n      throw new Error(`${BASE_DIR} not found`);\n    }\n    return result.size;\n  }\n}\n\nconst getCacheEntry = async (cacheKey: string): Promise<{ exists: boolean; path: string; tmpPath: string }> => {\n  const filename = cacheKey.substring(\n    cacheKey.lastIndexOf(\"/\"),\n    cacheKey.indexOf(\"?\") === -1 ? cacheKey.length : cacheKey.indexOf(\"?\")\n  );\n  const ext = filename.indexOf(\".\") === -1 ? \".jpg\" : filename.substring(filename.lastIndexOf(\".\"));\n  const sha = SHA1(cacheKey);\n  const path = `${BASE_DIR}${sha}${ext}`;\n  const tmpPath = `${BASE_DIR}${sha}-${_.uniqueId()}${ext}`;\n  // TODO: maybe we don't have to do this every time\n  try {\n    await FileSystem.makeDirectoryAsync(BASE_DIR);\n  } catch (e) {\n    // do nothing\n  }\n  const info = await FileSystem.getInfoAsync(path);\n  const { exists } = info;\n  return { exists, path, tmpPath };\n};\n"]}